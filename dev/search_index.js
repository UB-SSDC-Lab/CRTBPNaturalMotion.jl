var documenterSearchIndex = {"docs":
[{"location":"lib/public/propagation/#Propagation-Functions","page":"Propagation","title":"Propagation Functions","text":"","category":"section"},{"location":"lib/public/propagation/","page":"Propagation","title":"Propagation","text":"Modules = [CRTBPNaturalMotion]\nPages = [\"integration.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_all_states-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any, Function, Function, Type{Time}}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_all_states","text":"propagate_return_all_states(\n    x0::SVector{6,TX},\n    tspan::Tuple{TT,TT},\n    mu,\n    cond::Function,\n    affect::Function,\n    iv::Type{AbstractIndependantVariable};\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the full ODE solution. This is done employing a DifferentialEquations.jl ContinuousCallback defined with cond and affect. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\nArguments\n\nx0::SVector{6,TX}: The initial state with x0 = [r0; v0].\ntspan::Tuple{TT,TT}: The span of the independant variable forwhich to solve the ODE.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\ncond::Function: The DifferentialEquations.jl continuous callback condition function   that will apply affect to the integrator struct (see   DifferentialEquations.jl callback documentation).\naffect::Function: The DifferentialEquations.jl continuous callback affect function.\niv::Type{AbstractIndependantVariable}: The desired independant variable (Time if   unspecified).\n\nKeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nReturns\n\nODESolution: The full solution to the ODE problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_all_states-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any, Function, Type{Time}}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_all_states","text":"propagate_return_all_states(\n    x0::SVector{6,TX},\n    tspan::Tuple{TT,TT},\n    mu,\n    term_cond::Function[, iv::Type{AbstractIndependantVariable}];\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the full ODE solution. At the first point at which term_cond is zero (if any), the integration will terminate. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\nArguments\n\nx0::SVector{6,TX}: The initial state with x0 = [r0; v0].\ntspan::Tuple{TT,TT}: The span of the independant variable forwhich to solve the ODE.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\nterm_cond::Function: The DifferentialEquations.jl continuous callback condition function   that will terminate the integration when it is zero. Function should be of the form   term_cond(x,t,integ), where x is the state, t is the independant variable, and   integ is the integrator struct (see DifferentialEquations.jl callback documentation).\niv::Type{AbstractIndependantVariable}: The desired independant variable (Time if   unspecified).\n\nKeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nReturns\n\nODESolution: The full solution to the ODE problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_all_states-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any, Type{Time}}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_all_states","text":"propagate_return_all_states(\n    x0::SVector{6,TX}, tspan::Tuple{TT,TT}, mu [, iv::Type{AbstractIndependantVariable}];\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the full ODE solution. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\nArguments\n\nx0::SVector{6,T}: The initial state with x0 = [r0; v0].\ntspan::Tuple{T,T}: The span of the independant variable forwhich to solve the ODE.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\niv::Type{AbstractIndependantVariable}: The desired independant variable (Time if   unspecified).\n\nKeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nReturns\n\nODESolution: The full solution to the ODE problem.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_all_states-Union{Tuple{TX}, Tuple{SVector{6, TX}, AbstractVector, Any, Type{Time}}} where TX","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_all_states","text":"propagate_return_all_states(\n    x0::SVector{6,TX},\n    tsteps::Union{StepRangeLen,AbstractVector},\n    mu,\n    iv::Type{AbstractIndependantVariable};\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where TX\n\nPropagate the state x0 from tsteps[1] to tsteps[end], returning the solution at each time in tsteps. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\nArguments\n\nx0::SVector{6,TX}: The initial state with x0 = [r0; v0].\ntsteps::Union{StepRangeLen,AbstractVector}: The time steps at which a state x(t) is desired.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\niv::Type{AbstractIndependantVariable}: The desired independant variable.\n\nKeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nReturns\n\nVector{SVector{6,TX}}: A vector of states at each time in tsteps.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_arc_length-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_arc_length","text":"propagate_return_arc_length(\n    x0::SVector{6,TX}, tspan::Tuple{TT,TT}, mu;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the arclength along the trajectory. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\narguments\n\nx0::SVector{6,TX}: the initial state with x0 = [r0; v0].\ntspan::Tuple{TT,TT}: the time span forwhich to solve the ode.\nmu::Real: the mass parameter of the three-body system (mu = m2 / (m1 + m2)).\n\nkeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nreturns\n\nTX: The arc-length along the curve\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_final_state-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any, Function, Type{Time}}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_final_state","text":"propagate_return_final_state(\n    x0::SVector{6,TX},\n    tspan::Tuple{TT,TT},\n    mu,\n    term_cond::Function [, iv::Type{AbstractIndependantVariable}];\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the final state. At the first point at which term_cond is zero (if any), the integration will terminate. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\nArguments\n\nx0::SVector{6,TX}: The initial state with x0 = [r0; v0].\ntspan::Tuple{TT,TT}: The span of the independant variable forwhich to solve the ODE.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\nterm_cond::Function: The DifferentialEquations.jl continuous callback condition function   that will terminate the integration when it is zero. Function should be of the form   term_cond(x,t,integ), where x is the state, t is the independant variable, and   integ is the integrator struct (see DifferentialEquations.jl callback documentation).\niv::Type{AbstractIndependantVariable}: The desired independant variable (Time if   unspecified).\n\nKeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nReturns\n\nSVector{6,TX}: The final state of the ODE solution.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_final_state-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any, Type{Time}}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_final_state","text":"propagate_return_final_state(\n    x0::SVector{6,TX}, tspan::Tuple{TT,TT}, mu [, iv::Type{AbstractIndependantVariable}];\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the final state. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\narguments\n\nx0::SVector{6,TX}: The initial state with x0 = [r0; v0].\ntspan::Tuple{TT,TT}: The span of the independant variable forwhich to solve the ode.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\niv::Type{AbstractIndependantVariable}: The desired independant variable (Time if   unspecified).\n\nkeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nreturns\n\nSVector{6,TX}: The final state of the ode solution.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_final_stm-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_final_stm","text":"propagate_return_final_stm(\n    x0::SVector{6,TX}, tspan::Tuple{TT,TT}, mu;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the final state transition matrix (STM).\n\narguments\n\nx0::SVector{6,TX}: The initial state with x0 = [r0; v0].\ntspan::Tuple{TT,TT}: The span of the independant variable forwhich to solve the ode.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\n\nkeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nreturns\n\nSMatrix{6,6,TX,36}: The stm for the full trajectory\n\n\n\n\n\n","category":"method"},{"location":"lib/public/propagation/#CRTBPNaturalMotion.propagate_return_time-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any}} where {TX, TT}","page":"Propagation","title":"CRTBPNaturalMotion.propagate_return_time","text":"propagate_return_time(\n    x0::SVector{6,TX}, sspan::Tuple{TT,TT}, mu;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the arc-length span sspan and return the arclength along the trajectory. The final argument can be specified to set the desired independant variable (i.e., Time or ArcLength).\n\narguments\n\nx0::SVector{6,TX}: the initial state with x0 = [r0; v0].\nsspan::Tuple{TT,TT}: the arc-length span forwhich to solve the ode.\nmu::Real: the mass parameter of the three-body system (mu = m2 / (m1 + m2)).\n\nkeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nreturns\n\nTX: The time along the curve\n\n\n\n\n\n","category":"method"},{"location":"lib/public/orbit_computation/#Periodic-Orbit-Computation","page":"Periodic Orbit Computation","title":"Periodic Orbit Computation","text":"","category":"section"},{"location":"lib/public/orbit_computation/","page":"Periodic Orbit Computation","title":"Periodic Orbit Computation","text":"Modules = [CRTBPNaturalMotion]\nPages = [\"periodic_orbits.jl\", \"periodic_orbit_correction.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.GeneralPeriodicOrbit","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.GeneralPeriodicOrbit","text":"GeneralPeriodicOrbit\n\nA general representation of a periodic orbit.\n\nFields\n\nx0::SVector{6, Float64}: The initial conditions for the periodic orbit.\nP::Float64: The period of the periodic orbit.\nS::Float64: The arc length along the periodic orbit.\nmu::Float64: The gravitational parameter of the CRTBP.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.TypeAPeriodicOrbit","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.TypeAPeriodicOrbit","text":"TypeAPeriodicOrbit(\n    rx, rz, vy, mu[, TU, DU];\n    N_cross = 1,\n    constraint = (:x_start_coordinate, 0.8),\n    ode_solver = Vern9(),\n    ode_reltol = 1e-12,\n    ode_abstol = 1e-12,\n    nl_solver  = SimpleTrustRegion(autodiff = nothing, nlsolve_update_rule = Val(true)),\n)\n\n\n\n\n\n","category":"type"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.TypeAPeriodicOrbit-2","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.TypeAPeriodicOrbit","text":"TypeAPeriodicOrbit\n\nA representation of a CRTBP periodic orbit of Type A.\n\nFields\n\nu0::SVector{3, Float64}: The initial conditions for the periodic orbit.\nP::Float64: The period of the periodic orbit.\nS::Float64: The arc length along the periodic orbit.\nN_cross::Int: The number of crossings through x-z plane in half period.\nmu::Float64: The gravitational parameter of the CRTBP.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.TypeAPeriodicOrbit-Tuple{TypeAPeriodicOrbit}","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.TypeAPeriodicOrbit","text":"TypeAPeriodicOrbit(\n    orbit::TypeAPeriodicOrbit;\n    constraint = (:x_start_coordinate, 0.8),\n    ode_solver = Vern9(),\n    ode_reltol = 1e-12,\n    ode_abstol = 1e-12,\n    nl_solver  = SimpleTrustRegion(autodiff = nothing, nlsolve_update_rule = Val(true)),\n)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.generate_periodic_orbit_cheb_approximation-Tuple{CRTBPNaturalMotion.AbstractPeriodicOrbit, Int64, Int64, Union{Type{ArcLength}, Type{Time}}}","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.generate_periodic_orbit_cheb_approximation","text":"generate_periodic_orbit_cheb_approximation(\n    orbit::AbstractPeriodicOrbit, τ1_npoints::Int, τ1_order::Int, PT::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) -> FastChebInterpolation{FastChebInterp.ChebPoly{1, SVector{6, Float64}, Float64}}\n\nGenerate a Chebyshev approximation of the periodic orbit in terms of PT employing τ1_npoints fit to a Chebyshev polynomial of order τ1_order.\n\nArguments\n\norbit::AbstractPeriodicOrbit: The periodic orbit.\nτ1_npoints::Int: The number of points to fit the Chebyshev polynomial.\nτ1_order::Int: The order of the Chebyshev polynomial.\nPT::ParameterizationType: The type of parameterization to use (Time or ArcLength).\n\nKeyword Arguments\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The ODE solver to use for the integration.\nreltol::Real: The relative tolerance for the ODE solver.\nabstol::Real: The absolute tolerance for the ODE solver.\n\nReturns\n\nFastChebInterpolation{FastChebInterp.ChebPoly{1, SVector{6, Float64}, Float64}}: The Chebyshev approximation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.generate_periodic_orbit_cheb_interpolation-Tuple{CRTBPNaturalMotion.AbstractPeriodicOrbit, Int64, Union{Type{ArcLength}, Type{Time}}}","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.generate_periodic_orbit_cheb_interpolation","text":"generate_periodic_orbit_cheb_interpolation(\n    orbit::AbstractPeriodicOrbit, τ1_order::Int, PT::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) -> FastChebInterpolation{FastChebInterp.ChebPoly{1, SVector{6, Float64}, Float64}}\n\nGenerate a Chebyshev interpolation of the periodic orbit in terms of PT employing a Chebyshev polynomial of order τ1_order.\n\nArguments\n\norbit::AbstractPeriodicOrbit: The periodic orbit.\nτ1_order::Int: The order of the Chebyshev polynomial.\nPT::ParameterizationType: The type of parameterization to use (Time or ArcLength).\n\nKeyword Arguments\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The ODE solver to use for the integration.\nreltol::Real: The relative tolerance for the ODE solver.\nabstol::Real: The absolute tolerance for the ODE solver.\n\nReturns\n\nFastChebInterpolation{FastChebInterp.ChebPoly{1, SVector{6, Float64}, Float64}}: The Chebyshev interpolation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.get_full_orbit-Tuple{CRTBPNaturalMotion.AbstractPeriodicOrbit}","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.get_full_orbit","text":"get_full_orbit(orbit::AbstractPeriodicOrbit)\n\nGet the full orbit of the periodic orbit.\n\nArguments\n\norbit::AbstractPeriodicOrbit: The periodic orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/orbit_computation/#CRTBPNaturalMotion.correct_typeA_initial_conditions-NTuple{4, Any}","page":"Periodic Orbit Computation","title":"CRTBPNaturalMotion.correct_typeA_initial_conditions","text":"correct_typeA_initial_conditions(\n    rx_guess, rz_guess, vy_guess, mu;\n    N_cross     = 1,\n    constraint  = (:x_start_coordinate, 0.0),\n    ode_solver  = Vern9(),\n    ode_reltol  = 1e-14,\n    ode_abstol  = 1e-14,\n    nl_solver   = SimpleTrustRegion(autodiff = nothing, nlsolve_update_rule = Val(true)),\n)\n\nCorrect the initial conditions of a type-A periodic orbit using a forward shooting method.\n\nArguments\n\nrx_guess::Real: Initial guess for the x-coordinate of the initial state.\nrz_guess::Real: Initial guess for the z-coordinate of the initial state.\nvy_guess::Real: Initial guess for the y-velocity of the initial state.\nmu::Real: Gravitational parameter of the CRTBP.\n\nKeyword Arguments\n\nN_cross::Int = 1: Number of crossings of the xz-plane to consider in the half period.\nconstraint::Tuple{Symbol,Real}: Tuple of the constraint type and value corresponding   to the final constraint considered to provide a fully defined system of nonlinear   eqautions. The constraint type can be either :x_start_coordinate or :jacobi_integral.   The constraint value is the value that the constraint should be equal to for the desired   periodic orbit.\node_solver::OrdinaryDiffEq.AbstractODESolver: The ODE solver to use for the integration.\node_reltol::Real: The relative tolerance for the ODE solver.\node_abstol::Real: The absolute tolerance for the ODE solver.\nnl_solver::NonlinearSolve.AbstractNLsolveSolver: The nonlinear solver to use for the   root-finding problem. Note, there seems to be a strange bug with the NonlinearSolve.jl   TrustRegion and NewtonRaphson solvers when using out-of-place Jacobian defined   to return an SMatrix. Therefore, it is recommened to use either the default   SimpleTrustRegion solver or the SimpleNewtonRaphson solver (which are specifically   tailored towards StaticArrays.jl arrays).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/jpl_orbits/#Querying-JPL-CRTBP-Periodic-Orbit-API","page":"Querying JPL Catelog","title":"Querying JPL CRTBP Periodic Orbit API","text":"","category":"section"},{"location":"lib/public/jpl_orbits/","page":"Querying JPL Catelog","title":"Querying JPL Catelog","text":"Modules = [CRTBPNaturalMotion]\nPages = [joinpath(\"jpl_catalog\",\"get_jpl_orbits.jl\")]\nPrivate = false","category":"page"},{"location":"lib/public/jpl_orbits/#CRTBPNaturalMotion.get_jpl_orbits-Tuple{String}","page":"Querying JPL Catelog","title":"CRTBPNaturalMotion.get_jpl_orbits","text":"Get periodic orbits from the JPL CRTBP Periodic Orbit API. See JPL's web application and API documentation for details.\n\nArguments\n\nquery::String: The query string to send to the JPL API. See JPL's API documentation   for details on manually constructing an HTTP Request query.\n\nKeyword Arguments\n\node_solver = Vern9(): The ODE solver to use for computing the orbits. Default is Vern9(). This is   only employed for computing the arc-length along the orbit.\node_reltol = 1e-14: Relative tolerance for the ODE solver. Default is 1e-14.\node_abstol = 1e-14: Absolute tolerance for the ODE solver. Default is 1e-14.\n\nReturns\n\nOrbitSet: A set of periodic orbits that meet the query criteria.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/jpl_orbits/#CRTBPNaturalMotion.get_jpl_orbits-Tuple{}","page":"Querying JPL Catelog","title":"CRTBPNaturalMotion.get_jpl_orbits","text":"get_jpl_orbits(;\n    sys         = \"earth-moon\",\n    family      = \"halo\",\n    libr        = 1,\n    branch      = \"N\",\n    periodmin   = nothing,\n    periodmax   = nothing,\n    periodunits = nothing,\n    jacobimin   = nothing,\n    jacobimax   = nothing,\n    stabmin     = nothing,\n    stabmax     = nothing,\n    ode_solver  = Vern9(),\n    ode_reltol  = 1e-14,\n    ode_abstol  = 1e-14,\n)\n\nGet periodic orbits from the JPL CRTBP Periodic Orbit API. See JPL's web application and API documentation for details.\n\nKeyword Arguments\n\nsys::String = \"earth-moon\": The system to get orbits for. Options include:\n\"earth-moon\"\n\"mars-phobos\"\n\"sun-earth\"\n\"sun-mars\"\n\"jupiter-europa\"\n\"saturn-enceladus\"\n\"saturn-titan\"\nfamily::String = \"halo\": The family of orbits to get. Options include:\n\"halo\"\n\"vertical\"\n\"axial\"\n\"lyapunov\"\n\"longp\"\n\"short\"\n\"butterfly\"\n\"dragonfly\"\n\"resonant\"\n\"dro\"\n\"dpo\"\n\"lpo\"\nlibr::Int = 1: The libration point to get orbits around. Default is 1. Requred for   \"halo\", \"lyapunov\" (1, 2, or 3), \"longp\", \"short\" (4 or 5), and \"axial\",   \"vertical\" (1, 2, 3, 4, or 5).\nbranch::String = \"N\": The branch of the family to get. Required for \"halo\",   \"dragonfly\", \"butterfly\" (\"N\" of \"S\"), \"lpo\" (\"E\" or \"W\"), and   \"resonant\" (e.g., \"12\" for 1:2 resonant orbits).\nperiodmin::Union{Float64,Nothing} = nothing: Minimum period of orbits to get. Default is nothing.\nperiodmax::Union{Float64,Nothing} = nothing: Maximum period of orbits to get. Default is nothing.\nperiodunits::Union{String,Nothing} = nothing: Units of period. Options include:\n\"s\": seconds\n\"h\": hours\n\"d\": days\n\"TU\": dimensionless time units\njacobimin::Union{Float64,Nothing} = nothing: Minimum Jacobi constant of orbits to get. Default is nothing.\njacobimax::Union{Float64,Nothing} = nothing: Maximum Jacobi constant of orbits to get. Default is nothing.\nstabmin::Union{Float64,Nothing} = nothing: Minimum stability of orbits to get. Default is nothing.\nstabmax::Union{Float64,Nothing} = nothing: Maximum stability of orbits to get. Default is nothing.\node_solver = Vern9(): The ODE solver to use for computing the orbits. Default is Vern9(). This is   only employed for computing the arc-length along the orbit.\node_reltol = 1e-14: Relative tolerance for the ODE solver. Default is 1e-14.\node_abstol = 1e-14: Absolute tolerance for the ODE solver. Default is 1e-14.\n\nReturns\n\nOrbitSet: A set of periodic orbits that meet the query criteria.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Public-API-Documentation","page":"Public API","title":"Public API Documentation","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Documentation for CRTBPNaturalMotion's public interface.","category":"page"},{"location":"lib/public/#Index","page":"Public API","title":"Index","text":"","category":"section"},{"location":"lib/public/","page":"Public API","title":"Public API","text":"Pages = [\n    \"public/jpl_orbits.md\", \n    \"public/orbit_computation.md\", \n    \"public/manifolds.md\",\n    \"public/propagation.md\",\n    \"public/type_flags.md\",\n    \"public/utilities.md\",\n]","category":"page"},{"location":"lib/public/manifolds/#Invariant-Manifold-Computation","page":"Stable/Unstable Manifolds","title":"Invariant Manifold Computation","text":"","category":"section"},{"location":"lib/public/manifolds/","page":"Stable/Unstable Manifolds","title":"Stable/Unstable Manifolds","text":"Modules = [CRTBPNaturalMotion]\nPages = [\"manifolds.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.InvariantManifold","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.InvariantManifold","text":"InvariantManifold{PO <: AbstractPeriodicOrbit}\n\nA struct for invariant manifolds of periodic orbits.\n\nFields\n\norbit::PO: The periodic orbit.\nΔr::Float64: The manifold perturbation size (change in position) along stable/unstable   eigenvector direction.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.generate_stable_manifold_cheb_approximation-Tuple{InvariantManifold, Bool, Int64, Int64, Union{Type{ArcLength}, Type{Time}}, Int64, Int64, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.generate_stable_manifold_cheb_approximation","text":"generate_stable_manifold_cheb_approximation(\n    man::InvariantManifold, left_pert::Bool,\n    τ1_npoints::Int, τ1_order::Int, PT1::ParameterizationType,\n    τ2_npoints::Int, τ2_order::Int, PT2::ParameterizationType;\n    start_cond::Union{Nothing,Function,AbstractFloat} = nothing,\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) -> FastChebInterpolation{FastChebInterp.ChebPoly{2, SVector{6, Float64}, Int64}}\n\nGenerate a Chebyshev approximation for the stable InvariantManifold in terms of PT1 and PT2 for the parameters τ1 and τ2 employing τ1_npoints and τ2_npoints to a Chebyshev polynomial of order τ1_order and τ2_order, respectively.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1_npoints::Int: The number of points to use in the τ1 direction.\nτ1_order::Int: The order of the Chebyshev interpolation in the τ1 direction.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nτ2_npoints::Int: The number of points to use in the τ2 direction.\nτ2_order::Int: The order of the Chebyshev interpolation in the τ2 direction.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nstart_cond::Union{Nothing,Function,AbstractFloat} = nothing: The starting condition for the   manifold trajectory. If a scalar, this specifies the distance from the initial condition on the   periodic orbit in terms of PT2. If a function, this specifies a termination condition callback   function for the solver that will be used to propagate to the initial state of the returned   trajectory from the initial condition on the periodic orbit.\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\nReturns\n\nFastChebInterpolation{FastChebInterp.ChebPoly{2, SVector{6, Float64}, Int64}}: The Chebyshev   interpolant for the stable manifold.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.generate_stable_manifold_cheb_interpolant-Tuple{InvariantManifold, Bool, Int64, Union{Type{ArcLength}, Type{Time}}, Int64, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.generate_stable_manifold_cheb_interpolant","text":"generate_stable_manifold_cheb_interpolant(\n    man::InvariantManifold, left_pert::Bool,\n    τ1_order::Int, PT1::ParameterizationType,\n    τ2_order::Int, PT2::ParameterizationType;\n    start_cond::Union{Nothing,Function,AbstractFloat} = nothing,\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) -> FastChebInterpolation{FastChebInterp.ChebPoly{2, SVector{6, Float64}, Int64}}\n\nGenerate a Chebyshev interpolant for the stable InvariantManifold.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1_order::Int: The order of the Chebyshev interpolation in the τ1 direction.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nτ2_order::Int: The order of the Chebyshev interpolation in the τ2 direction.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nstart_cond::Union{Nothing,Function,AbstractFloat} = nothing: The starting condition for the   manifold trajectory. If a scalar, this specifies the distance from the initial condition on the   periodic orbit in terms of PT2. If a function, this specifies a termination condition callback   function for the solver that will be used to propagate to the initial state of the returned   trajectory from the initial condition on the periodic orbit.\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\nReturns\n\nFastChebInterpolation{FastChebInterp.ChebPoly{2, SVector{6, Float64}, Int64}}: The Chebyshev   interpolant for the stable manifold.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.generate_stable_manifold_cross_section_cheb_approximation-Tuple{InvariantManifold, Bool, Int64, Int64, Union{Type{ArcLength}, Type{Time}}, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.generate_stable_manifold_cross_section_cheb_approximation","text":"generate_stable_manifold_cross_section_cheb_approximation(\n    man::InvariantManifold, left_pert::Bool,\n    τ1_order::Int, PT1::ParameterizationType,\n    τ2::AbstractFloat, PT2::ParameterizationType;\n    start_cond::Union{Nothing,Function,AbstractFloat} = nothing,\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) -> FastChebInterpolation{FastChebInterp.ChebPoly{1, SVector{6, Float64}, Int64}}\n\nGenerate a Chebyshev interpolant for a cross-section of the stable InvariantManifold through a least-squares fit to\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1_npoints::Int: The number of points to use in the τ1 direction.\nτ1_order::Int: The order of the Chebyshev interpolation in the τ1 direction.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nτ2::AbstractFloat: The fixed choice for the τ2 parameter, which specified the location   of the fixed manifold cross-section.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nstart_cond::Union{Nothing,Function,AbstractFloat} = nothing: The starting condition for the   manifold trajectory. If a scalar, this specifies the distance from the initial condition on the   periodic orbit in terms of PT2. If a function, this specifies a termination condition callback   function for the solver that will be used to propagate to the initial state of the returned   trajectory from the initial condition on the periodic orbit.\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\nReturns\n\nFastChebInterpolation{FastChebInterp.ChebPoly{2, SVector{6, Float64}, Int64}}: The Chebyshev   interpolant for the stable manifold.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.generate_stable_manifold_cross_section_cheb_interpolant-Tuple{InvariantManifold, Bool, Int64, Union{Type{ArcLength}, Type{Time}}, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.generate_stable_manifold_cross_section_cheb_interpolant","text":"generate_stable_manifold_cross_section_cheb_interpolant(\n    man::InvariantManifold, left_pert::Bool,\n    τ1_order::Int, PT1::ParameterizationType,\n    τ2::AbstractFloat, PT2::ParameterizationType;\n    start_cond::Union{Nothing,Function,AbstractFloat} = nothing,\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) -> FastChebInterpolation{FastChebInterp.ChebPoly{1, SVector{6, Float64}, Int64}}\n\nGenerate a Chebyshev interpolant for a cross-section of the stable InvariantManifold.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1_order::Int: The order of the Chebyshev interpolation in the τ1 direction.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nτ2::AbstractFloat: The fixed choice for the τ2 parameter, which specified the location   of the fixed manifold cross-section.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nstart_cond::Union{Nothing,Function,AbstractFloat} = nothing: The starting condition for the   manifold trajectory. If a scalar, this specifies the distance from the initial condition on the   periodic orbit in terms of PT2. If a function, this specifies a termination condition callback   function for the solver that will be used to propagate to the initial state of the returned   trajectory from the initial condition on the periodic orbit.\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\nReturns\n\nFastChebInterpolation{FastChebInterp.ChebPoly{2, SVector{6, Float64}, Int64}}: The Chebyshev   interpolant for the stable manifold.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_stable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, AbstractFloat, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_stable_manifold_trajectory","text":"get_stable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat, PT1::ParameterizationType,\n    start_cond::Union{AbstractFloat,Function},\n    τ2::Union{AbstractFloat,ParameterListType}, PT2::ParameterizationType;\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single stable manifold trajectory corresponding to the parameters τ1 and τ2. Here, the starting point of the returned trajectory is determined by the argument start_cond. If start_cond is a scalar, this specifies the distance from the initial condition on the periodic orbit in terms of PT2. If start_cond is a function, this specifies a termination condition callback function for the solver that will be used to propagate to the initial state of the returned trajectory from the initial condition on the periodic orbit.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nstart_cond::Union{AbstractFloat,Function}: The starting condition for the manifold trajectory.   If a scalar, this specifies the distance from the initial condition on the periodic orbit in terms   of PT2. If a function, this specifies a termination condition callback function for the solver   that will be used to propagate to the initial state of the returned trajectory from the initial   condition on the periodic orbit.\nτ2::Union{AbstractFloat,ParameterListType}: The parameter for the final condition on the   manifold. If a single scalar is provided, the returned trajectory is a DifferentialEquations.jl   solution struct. If a list is provided, the returned trajectory is an array of states   corresponding to each element in the list.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length,   starting from the state parameterized by start_cond.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_stable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_stable_manifold_trajectory","text":"get_stable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat, PT1::ParameterizationType,\n    τ2::Union{AbstractFloat,ParameterListType}, PT2::ParameterizationType;\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single stable manifold trajectory corresponding to the parameters τ1 and τ2.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nτ2::Union{AbstractFloat,ParameterListType}: The parameter for the final condition on the   manifold. If a single scalar is provided, the returned trajectory is a DifferentialEquations.jl   solution struct. If a list is provided, the returned trajectory is an array of states   corresponding to each element in the list.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_stable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, Function, Function, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_stable_manifold_trajectory","text":"get_stable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat, PT1::ParameterizationType,\n    start_cond::Function, term_cond::Function, PT2::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single stable manifold trajectory given scalar parameter τ1, where the starting state of the returned trajectory is determined through the satisfaction of start_cond and the final state is determined through the satisfaction of term_cond, where start_cond and term_cond are termination condition callback functions.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nstart_cond::Function: The starting condition callback function for the solver.\nterm_cond::Function: The termination condition callback function for the solver.\nPT2::ParameterizationType: The parameterization type for the final condition on the manifold.\n\nKeyword Arguments\n\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_stable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, Function, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_stable_manifold_trajectory","text":"get_stable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat,   PT1::ParameterizationType,\n    term_cond::Function, PT2::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single stable manifold trajectory given scalar parameter τ1, where the final state of the returned trajectory is determined through the satisfaction of term_cond, a termination condition callback function.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nterm_cond::Function: The termination condition callback function for the solver.\nPT2::ParameterizationType: The parameterization type for the final condition on the manifold.\n\nKeyword Arguments\n\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_unstable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, AbstractFloat, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_unstable_manifold_trajectory","text":"get_unstable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat, PT1::ParameterizationType,\n    start_cond::Union{AbstractFloat,Function},\n    τ2::Union{AbstractFloat,ParameterListType}, PT2::ParameterizationType;\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single unstable manifold trajectory corresponding to the parameters τ1 and τ2. Here, the starting point of the returned trajectory is determined by the argument start_cond. If start_cond is a scalar, this specifies the distance from the initial condition on the periodic orbit in terms of PT2. If start_cond is a function, this specifies a termination condition callback function for the solver that will be used to propagate to the initial state of the returned trajectory from the initial condition on the periodic orbit.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nstart_cond::Union{AbstractFloat,Function}: The starting condition for the manifold trajectory.   If a scalar, this specifies the distance from the initial condition on the periodic orbit in terms   of PT2. If a function, this specifies a termination condition callback function for the solver   that will be used to propagate to the initial state of the returned trajectory from the initial   condition on the periodic orbit.\nτ2::Union{AbstractFloat,ParameterListType}: The parameter for the final condition on the   manifold. If a single scalar is provided, the returned trajectory is a DifferentialEquations.jl   solution struct. If a list is provided, the returned trajectory is an array of states   corresponding to each element in the list.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length,   starting from the state parameterized by start_cond.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_unstable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_unstable_manifold_trajectory","text":"get_unstable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat, PT1::ParameterizationType,\n    τ2::Union{AbstractFloat,ParameterListType}, PT2::ParameterizationType;\n    manifold_length::AbstractFloat = 1.0,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single unstable manifold trajectory corresponding to the parameters τ1 and τ2.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nτ2::Union{AbstractFloat,ParameterListType}: The parameter for the final condition on the   manifold. If a single scalar is provided, the returned trajectory is a DifferentialEquations.jl   solution struct. If a list is provided, the returned trajectory is an array of states   corresponding to each element in the list.\nPT2::ParameterizationType: The parameterization type for the τ2 parameter.\n\nKeyword Arguments\n\nmanifold_length::AbstractFloat = 1.0: The length of the manifold, in CRTBP units. Sets   the max length of the manifold, where τ2 = 1.0 corresponds to the full manifold_length.\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_unstable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, Function, Function, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_unstable_manifold_trajectory","text":"get_unstable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat, PT1::ParameterizationType,\n    start_cond::Function, term_cond::Function, PT2::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single unstable manifold trajectory given scalar parameter τ1, where the starting state of the returned trajectory is determined through the satisfaction of start_cond and the final state is determined through the satisfaction of term_cond, where start_cond and term_cond are termination condition callback functions.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nstart_cond::Function: The starting condition callback function for the solver.\nterm_cond::Function: The termination condition callback function for the solver.\nPT2::ParameterizationType: The parameterization type for the final condition on the manifold.\n\nKeyword Arguments\n\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/manifolds/#CRTBPNaturalMotion.get_unstable_manifold_trajectory-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}, Function, Union{Type{ArcLength}, Type{Time}}}","page":"Stable/Unstable Manifolds","title":"CRTBPNaturalMotion.get_unstable_manifold_trajectory","text":"get_unstable_manifold_trajectory(\n    man::InvariantManifold, left_pert::Bool,\n    τ1::AbstractFloat,   PT1::ParameterizationType,\n    term_cond::Function, PT2::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns a single unstable manifold trajectory given scalar parameter τ1, where the final state of the returned trajectory is determined through the satisfaction of term_cond, a termination condition callback function.\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT1::ParameterizationType: The parameterization type for the τ1 parameter.\nterm_cond::Function: The termination condition callback function for the solver.\nPT2::ParameterizationType: The parameterization type for the final condition on the manifold.\n\nKeyword Arguments\n\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\n\n\n\n\n","category":"method"},{"location":"interpolation_example/#Interpolation-in-CRTBPNaturalMotion.jl","page":"Interpolation","title":"Interpolation in CRTBPNaturalMotion.jl","text":"","category":"section"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"CRTBPNaturalMotion.jl implements several methods for approximating periodic orbits or their associated stable/unstable invariant manifolds. Currently all methods employ Chebyshev polynomials from FastChebInterp.jl.","category":"page"},{"location":"interpolation_example/#Interpolation-of-Periodic-Orbits","page":"Interpolation","title":"Interpolation of Periodic Orbits","text":"","category":"section"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"All periodic orbits in CRTBPNaturalMotion.jl can be approximated via Chebyshev polynomials, either through interpolation or least-squares regression. To demonstrate this functionality, we'll employ an axial periodic orbit about L_4 in the Earth-Moon system:","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    using CRTBPNaturalMotion\n\n    axial_orbit = get_jpl_orbits(;\n        sys         = \"earth-moon\",\n        family      = \"axial\",\n        libr        = 4,\n        periodmin   = 20.0,\n        periodmax   = 21.0,\n        periodunits = \"d\",\n    )[1]","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"Next, we'll create two different FastChebInterpolations, one representing an interpolation of the periodic orbit, and another representing an approximation of the orbit employing a least-squares fit to a Chebyshev polynomial of the same order. Note that we'll generate both as functions of the scaled ArcLength, i.e., τ in 0 1.","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    # Define order of both polynomials\n    polynomial_order = 100\n\n    # Define number of points to employ in least-squares fit\n    lsq_npoints = 150\n\n    # Generate interpolation of orbit\n    orbit_interp = generate_periodic_orbit_cheb_interpolation(\n        axial_orbit, polynomial_order, ArcLength,\n    )\n\n    # Generate approximation with least-squares regression\n    orbit_lsqf = generate_periodic_orbit_cheb_approximation(\n        axial_orbit, lsq_npoints, polynomial_order, ArcLength,\n    )\n\n    # Let's get the value of each polynomial for some τ\n    τ = 0.3256\n    println(value(orbit_interp, τ))\n    println(value(orbit_lsqf, τ))","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"Clearly, we get similar values from either polynomial representation. Note we can also easily compute the Jacobian of the polynomial approximations with: ","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    jacobian(orbit_lsqf, τ) ","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"Let's now see the approximation error using both methods.","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    using CairoMakie\n\n    N = 10000\n    τs = range(0.0, 1.0; length = N)\n    interp_errors = zeros(6, N)\n    lsqf_errors = zeros(6, N)\n    for (i, τ) in enumerate(τs)\n        # Propagate dynamics from initial reference state (uses Vern9() \n        # with absolute and relative tolerance of 1e-14 be default)\n        prop_state = CRTBPNaturalMotion.propagate_from_initial_conditions(\n            axial_orbit, τ, ArcLength,\n        )\n\n        # Compute errors\n        interp_errors[:, i] .= prop_state - value(orbit_interp, τ)\n        lsqf_errors[:, i] .= prop_state - value(orbit_lsqf, τ)\n    end\n\n    # Plot position and velocity errors in x-direction with units of m\n    fig = Figure()\n    ax_rx = Axis(fig[1,1]; xlabel = L\"\\tau\", ylabel=L\"$r_x$ error (m)\")\n    lines!(\n        ax_rx, τs, lsqf_errors[1,:]*(axial_orbit.DU*1000); \n        linewidth   = 1,\n        color       = :green, \n        label       = \"Least-Squares approx.\",\n    )\n    lines!(\n        ax_rx, τs, interp_errors[1,:]*(axial_orbit.DU*1000); \n        linewidth   = 1,\n        color       = :blue,\n        label       = \"Interpolation\",\n    )\n    axislegend(ax_rx)\n\n    ax_vx = Axis(fig[2,1]; xlabel = L\"\\tau\", ylabel=L\"$v_x$ error (m/s)\")\n    lines!(\n        ax_vx, τs, lsqf_errors[4,:]*(axial_orbit.DU*1000/axial_orbit.TU); \n        linewidth   = 1,\n        color       = :green, \n        label       = \"Least-Squares approx.\",\n    )\n    lines!(\n        ax_vx, τs, interp_errors[4,:]*(axial_orbit.DU*1000/axial_orbit.TU); \n        linewidth   = 1,\n        color       = :blue,\n        label       = \"Interpolation\",\n    )\n    save(\"halo_orbit_approx_error.svg\", fig); nothing # hide","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"(Image: )","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"As can be seen, both approximations are quite good, with the least-squares approximation exhibiting the smallest maximum error whereas the interpolation exhibits smaller error for values of the parameter tau near the boundaries.","category":"page"},{"location":"interpolation_example/#Stable-Invariant-Manifold","page":"Interpolation","title":"Stable Invariant Manifold","text":"","category":"section"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"All InvariantManifolds in CRTBPNaturalMotion.jl can also be approximated with Chebyshev polynomials. We can construct a bi-variate approximation of a full manifold surface or a uni-variate approximation of a manifold cross-section (both with interpolation and least-squares regression). To demonstrate this, we'll first construct an InvariantManifold for an L_1 halo orbit as follows:","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    # Define halo orbit and manifold\n    halo = get_jpl_orbits(;\n        sys         = \"earth-moon\",\n        family      = \"halo\",\n        libr        = 1, \n        jacobimin   = 3.104,\n        jacobimax   = 3.105,\n    )[1]\n    man = InvariantManifold(halo, 50.0 / halo.DU)\n\n    # Some convenience variables for computing manifold\n    man_start = 0.75 \n    man_length = 6e5 / halo.DU\n\n    # Lets plot some trajectories on the manifold\n    fig = Figure()\n    ax  = Axis(fig[1,1]; aspect = DataAspect(), xlabel = L\"$r_x$, DU\", ylabel = L\"$r_y$, DU\")\n    τs  = range(0.0, 1.0; length=16)[1:end-1]\n    for τ in τs\n        # Get the initial manifold trajectory for better visualization of what is going on\n        init_man_traj = get_stable_manifold_trajectory(\n            man, true, τ, ArcLength, 0.0, 1.0, ArcLength;\n            manifold_length = man_start \n        )\n\n        # Get the manifold trajectory that we'll actually use\n        man_traj = get_stable_manifold_trajectory(\n            man, true, τ, ArcLength, man_start, 1.0, ArcLength;\n            manifold_length = man_length # 8e5 km divided by the distance unit\n        )\n        lines!(ax, init_man_traj[1,:], init_man_traj[2,:]; color = (:black, 0.5))\n        lines!(ax, man_traj[1,:], man_traj[2,:]; color = :blue)\n    end\n    save(\"stable_manifold_plot.svg\", fig); nothing # hide","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"(Image: )","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"Note that we're specifying that we're only interested in the last 8 times 10^5 km of the stable manifold, such that τ2 = 1.0 corresponds states on the manifold that are a distance of 8 times 10^5 km, in terms of ArcLength along the manifold. ","category":"page"},{"location":"interpolation_example/#Approximation-of-a-Manifold-Cross-Section","page":"Interpolation","title":"Approximation of a Manifold Cross-Section","text":"","category":"section"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"Let's first consider approximating a single cross section of this stable manifold. We'll consider a cross section that is located 5 times 10^5 km from the halo orbit, in terms of the ArcLength along the manifold. To visualize this cross-section, we can plot it as follows:","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    fig = Figure()\n    ax = Axis(fig[1,1]; aspect = DataAspect(), xlabel = L\"$r_x$, DU\", ylabel = L\"$r_y$, DU\")\n    \n    # First plot the halo orbit itself\n    halo_traj = get_full_orbit(halo)\n    lines!(ax, halo_traj[1,:], halo_traj[2,:], halo_traj[3,:]; color = :black)\n\n    # Define cross-section location\n    cross_section_location = 3e5 / halo.DU\n    cross_section_τ2 = cross_section_location / man_length\n\n    # Plot cross-section\n    N = 100\n    τ1s = range(0.0, 1.0; length = N)\n    cs_states = zeros(6, N)\n    for (i, τ1) in enumerate(τ1s)\n        manifold_state = get_stable_manifold_trajectory(\n            man, true, τ1, ArcLength, man_start, cross_section_τ2, ArcLength;\n            manifold_length = man_length, \n        )[end]\n        cs_states[:,i] .= manifold_state\n    end\n    lines!(ax, cs_states[1,:], cs_states[2,:], cs_states[3,:]; color = :blue)\n\n    # Plot manifold trajectories\n    τs  = range(0.0, 1.0; length=16)[1:end-1]\n    for τ in τs\n        man_traj = get_stable_manifold_trajectory(\n            man, true, τ, ArcLength, 0.0, 1.0, ArcLength;\n            manifold_length = man_start + man_length\n        )\n        lines!(ax, man_traj[1,:], man_traj[2,:]; color = (:black, 0.5))\n    end\n\n    save(\"manifold_cross_section_plot.svg\", fig); nothing # hide","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"(Image: )","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"The Chebyshev polynomial approximations can be constructed with:","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    # First define polynomial order and the number of points to use in the \n    # least-squares fit\n    τ1_order = 120\n    τ1_npoints = 200\n\n\n    man_5e5_cs_interp = generate_stable_manifold_cross_section_cheb_interpolant(\n        man, true, τ1_order, ArcLength, cross_section_τ2, ArcLength;\n        start_cond = man_start,\n        manifold_length = man_length,\n    )\n    man_5e5_cs_lsqf = generate_stable_manifold_cross_section_cheb_approximation(\n        man, true, τ1_npoints, τ1_order, ArcLength, cross_section_τ2, ArcLength;\n        start_cond = man_start,\n        manifold_length = man_length,\n    )\n\n    τ1 = 0.3256\n    println(value(man_5e5_cs_interp, τ1))\n    println(value(man_5e5_cs_lsqf, τ1))","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"Again, lets look at the approximation error using both methods by plotting with CairoMakie.jl:","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    N = 1000\n    τ1_check_steps = range(0.0, 1.0; length = N)\n    interp_error = zeros(6, N)\n    lsqf_error = zeros(6, N)\n    for (i, τ1) in enumerate(τ1_check_steps)\n        manifold_state = get_stable_manifold_trajectory(\n            man, true, τ1, ArcLength, man_start, cross_section_τ2, ArcLength;\n            manifold_length = man_length, \n        )[end]\n        interp_error[:,i] .= value(man_5e5_cs_interp, τ1) - manifold_state\n        lsqf_error[:,i] .= value(man_5e5_cs_lsqf, τ1) - manifold_state\n    end\n\n    # Plot position and velocity errors in x-direction with units of m and m/s\n    fig = Figure()\n    ax_rx = Axis(fig[1,1]; xlabel = L\"\\tau_1\", ylabel=L\"$r_x$ error (m)\")\n    lines!(\n        ax_rx, τ1_check_steps, lsqf_error[1,:]*(halo.DU*1000); \n        linewidth   = 1,\n        color       = :green, \n        label       = \"Least-Squares approx.\",\n    )\n    lines!(\n        ax_rx, τ1_check_steps, interp_error[1,:]*(halo.DU*1000); \n        linewidth   = 1,\n        color       = :blue,\n        label       = \"Interpolation\",\n    )\n    axislegend(ax_rx)\n\n    ax_vx = Axis(fig[2,1]; xlabel = L\"\\tau_1\", ylabel=L\"$v_x$ error (m/s)\")\n    lines!(\n        ax_vx, τ1_check_steps, lsqf_error[4,:]*(halo.DU*1000/halo.TU); \n        linewidth   = 1,\n        color       = :green, \n        label       = \"Least-Squares approx.\",\n    )\n    lines!(\n        ax_vx, τ1_check_steps, interp_error[4,:]*(halo.DU*1000/halo.TU); \n        linewidth   = 1,\n        color       = :blue,\n        label       = \"Interpolation\",\n    )\n    save(\"manifold_cross_section_approx_error.svg\", fig); nothing # hide","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"(Image: )","category":"page"},{"location":"interpolation_example/#Approximation-of-a-Full-Manifold-Surface","page":"Interpolation","title":"Approximation of a Full Manifold Surface","text":"","category":"section"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"Finally, we'll compute an approximation of the full InvariantManifold surface. In the following code example, we'll construct an interpolant of the full manifold and will compute the approximation error.","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"    # First define order of polynomial for each variable and the number of points\n    # in each dimension to use in the least-squares fit\n    τ1_order = 80\n    τ2_order = 80\n    τ1_npionts = 150\n    τ2_npoints = 150\n\n    # Construct the interpolant\n    man_interp = generate_stable_manifold_cheb_interpolant(\n        man, true, τ1_order, ArcLength, τ2_order, ArcLength;\n        start_cond = man_start,\n        manifold_length = man_length, \n    )\n\n    # Construct the least-squares approximation\n    man_lsqf = generate_stable_manifold_cheb_approximation(\n        man, true, τ1_npoints, τ1_order, ArcLength, τ2_npoints, τ2_order, ArcLength;\n        start_cond = man_start,\n        manifold_length = man_length, \n    )\n\n    # Compute manifold interpolation error\n    N = 1000\n    τ1_check_steps = range(0.0, 1.0, length = N)\n    τ2_check_steps = range(0.0, 1.0, length = N)\n    interp_errors  = zeros(6, N, N)\n    lsqf_errors    = zeros(6, N, N)\n    for (i,τ1) in enumerate(τ1_check_steps)\n        manifold_states = get_stable_manifold_trajectory(\n            man, true, τ1, ArcLength, man_start, τ2_check_steps, ArcLength;\n            manifold_length = man_length,\n        )\n        for j in eachindex(manifold_states)\n            τ2 = τ2_check_steps[j]\n            prop_val = manifold_states[j]\n            interp_val = value(man_interp, τ1, τ2)\n            lsqf_val = value(man_lsqf, τ1, τ2)\n            interp_errors[:,i,j] .= interp_val - prop_val\n            lsqf_errors[:,i,j] .= lsqf_val - prop_val\n        end\n    end\n\n    # Plot interpolation error surface for x position and velocity\n    fig1 = Figure()\n    ax1 = Axis3(fig1[1,1]; xlabel=L\"\\tau_1\", ylabel=L\"\\tau_2\", zlabel=L\"$r_x$ error, m\")\n    surface!(\n        ax1, τ1_check_steps, τ2_check_steps, interp_errors[1,:,:]*(halo.DU*1000.0); \n        colormap = :viridis,\n    )\n\n    fig2 = Figure()\n    ax2 = Axis3(fig2[2,1]; xlabel=L\"\\tau_1\", ylabel=L\"\\tau_2\", zlabel=L\"$r_x$ error, m\")\n    surface!(\n        ax2, τ1_check_steps, τ2_check_steps, lsqf_errors[1,:,:]*(halo.DU*1000.0); \n        colormap = :viridis,\n    )\n    save(\"man_interp_error.svg\", fig1); nothing # hide\n    save(\"man_lsqf_error.svg\", fig2); nothing # hide","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"(Image: )","category":"page"},{"location":"interpolation_example/","page":"Interpolation","title":"Interpolation","text":"(Image: )","category":"page"},{"location":"jpl_api_example/#Querying-JPL's-CRTBP-Poincare-Catalog-of-Periodic-Orbits","page":"Querying the JPL API","title":"Querying JPL's CRTBP Poincare Catalog of Periodic Orbits","text":"","category":"section"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"CRTBPNaturalMotion.jl provides an interface to JPL's CRTBP Poincare catalog of periodic orbits through the exported function get_jpl_orbits. Through several keyword arguments (see the get_jpl_orbits docstring), which directly correspond to the in JPL's web application and API documentation, an OrbitSet of periodic orbits can be obtained for various three-body systems (e.g., Earth-Moon, Sun-Earth, Saturn-Enceladus, etc...).","category":"page"},{"location":"jpl_api_example/#Earth-Moon-Halo-orbits","page":"Querying the JPL API","title":"Earth-Moon Halo orbits","text":"","category":"section"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"As a simple example, we can obtain the full set of periodic orbits about the L_1 Libration point as follows:","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"using CRTBPNaturalMotion\n\norbits = get_jpl_orbits(;\n    sys     = \"earth-moon\",\n    family  = \"halo\",\n    libr    = 1,\n)","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"As can be seen, a total of 5731 orbits are contained within the OrbitSet exhibiting a range of different orbital periods, Jacobi constants, and stability values. ","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"Perhaps we're only interested in halo orbits exhibiting a stability index that is less than 5, with orbital periods between 10 and 11 days. We can refine our query using some additional keyword arguments as follows:","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"stable_orbits = get_jpl_orbits(;\n    sys         = \"earth-moon\",\n    family      = \"halo\",\n    libr        = 1,\n    periodmin   = 10.0,\n    periodmax   = 11.0,\n    periodunits = \"d\",\n    stabmax     = 5.0,\n)","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"The returned OrbitSet is implemented as a sub-type of Julia's AbstractVector{T} and therefore functions such as length(::OrbitSet) and indexing, i.e., ","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"first_orbit = stable_orbits[1]","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"and ","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"stable_orbits_subset = stable_orbits[[3,5,10,12]]","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"can be employed to obtain a single GeneralPeriodicOrbit or a subset of the original OrbitSet. Note that an OrbitSet is essentially a Vector{GeneralPeriodicOrbit} with some extra information about the three-body System and the contained periodic orbits. ","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"We can obtain a full trajectory for the periodic orbit as shown in Computing Halo Orbits using the get_full_orbit method. For example, several orbits within stable_orbits can be plotted using CairoMakie.jl as follows:","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"using CairoMakie\n\nfig = Figure(; size = (700, 1000))\nax  = Axis3(\n    fig[1,1]; \n    aspect = :data,\n    xlabel = L\"$r_x$, DU\",\n    ylabel = L\"$r_y$, DU\",\n    zlabel = L\"$r_z$, DU\",   \n)\n\n# Plot every 10 orbits\nfor i in 1:10:length(stable_orbits)\n    traj = get_full_orbit(stable_orbits[i])\n    lines!(ax, traj[1,:], traj[2,:], traj[3,:]; color = :blue)\nend\n\n#  Plot the moon\nimport FileIO\nplot_moon(ax, orbit_set) = begin # Defining a function that we can use later\n    moon = Sphere(\n        Point3f(1.0 - orbit_set.system.mass_ratio, 0.0, 0.0),\n        orbit_set.system.radius_secondary / orbit_set.system.DU\n    )\n    mesh!(ax, moon; color = FileIO.load(CairoMakie.assetpath(\"moon.png\")))\nend\nplot_moon(ax, stable_orbits)\nsave(\"jpl_halos.svg\", fig); nothing # hide","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"(Image: )","category":"page"},{"location":"jpl_api_example/#Quick-examples","page":"Querying the JPL API","title":"Quick examples","text":"","category":"section"},{"location":"jpl_api_example/#Plotting-a-subset-of-the-Earth-Moon-Butterfly-orbits","page":"Querying the JPL API","title":"Plotting a subset of the Earth-Moon Butterfly orbits","text":"","category":"section"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"butterfly_orbits = get_jpl_orbits(;\n    sys         = \"earth-moon\",\n    family      = \"butterfly\",\n    periodmin   = 12.0,\n    periodmax   = 15.0,\n    periodunits = \"d\",\n)\n\nbutterfly_fig = Figure()\nbutterfly_ax  = Axis3(\n    butterfly_fig[1,1]; \n    aspect = :data,\n    xlabel = L\"$r_x$, DU\",\n    ylabel = L\"$r_y$, DU\",\n    zlabel = L\"$r_z$, DU\",   \n)\n\n# Plot every 100 orbits and moon\nfor i in 1:100:length(butterfly_orbits)\n    traj = get_full_orbit(butterfly_orbits[i])\n    lines!(butterfly_ax, traj[1,:], traj[2,:], traj[3,:]; color = :blue)\nend\nplot_moon(butterfly_ax, butterfly_orbits)\nsave(\"jpl_butterflys.svg\", butterfly_fig) # hide","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"(Image: )","category":"page"},{"location":"jpl_api_example/#Plotting-all-of-the-Earth-Moon-Axial-orbits-about-L_4","page":"Querying the JPL API","title":"Plotting all of the Earth-Moon Axial orbits about L_4","text":"","category":"section"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"axial_orbits = get_jpl_orbits(;\n    sys         = \"earth-moon\",\n    family      = \"axial\",\n    libr        = 4,\n)\n\naxial_fig = Figure(; size = (800,600))\naxial_ax_xy  = Axis(\n    axial_fig[1,1]; \n    aspect = DataAspect(),\n    xlabel = L\"$r_x$, DU\",\n    ylabel = L\"$r_y$, DU\",\n)\naxial_ax_xz  = Axis(\n    axial_fig[1,2]; \n    aspect = DataAspect(),\n    xlabel = L\"$r_x$, DU\",\n    ylabel = L\"$r_z$, DU\",\n)\n\n# Plot every 200 orbits and moon\nfor i in 1:200:length(axial_orbits)\n    traj = get_full_orbit(axial_orbits[i])\n    lines!(axial_ax_xy, traj[1,:], traj[2,:]; color = :blue)\n    lines!(axial_ax_xz, traj[2,:], traj[3,:]; color = :blue)\nend\nsave(\"jpl_axial.svg\", axial_fig); nothing # hide","category":"page"},{"location":"jpl_api_example/","page":"Querying the JPL API","title":"Querying the JPL API","text":"(Image: )","category":"page"},{"location":"lib/public/utilities/#Utility-Functions","page":"Utilities","title":"Utility Functions","text":"","category":"section"},{"location":"lib/public/utilities/","page":"Utilities","title":"Utilities","text":"Modules = [CRTBPNaturalMotion]\nPages = [\"utils.jl\", \"interpolation.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/utilities/#CRTBPNaturalMotion.jacobi_integral-Tuple{Any, Any}","page":"Utilities","title":"CRTBPNaturalMotion.jacobi_integral","text":"jacobi_integral(x, μ)\n\nComputes the Jacobi integral for the CRTBP given the state x and mass parameter μ.\n\nArguments\n\nx::AbstractVector: State vector.\nμ::Real: Mass parameter.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/utilities/#CRTBPNaturalMotion.jacobian-Union{Tuple{IT}, Tuple{CRTBPNaturalMotion.FastChebInterpolation{IT}, Any, Any}} where IT","page":"Utilities","title":"CRTBPNaturalMotion.jacobian","text":"jacobian(m::FastChebInterpolation{IT}, τ1, τ2) where IT -> SMatrix{6, 2, Float64, 12}\n\nEvaluate the Jacobian of the interpolation at the given τ1 and τ2 for a bi-variate interpolation.\n\nArguments\n\nm::FastChebInterpolation{IT}: The interpolation object.\nτ1: The first variable.\nτ2: The second variable.\n\nReturns\n\nSMatrix{6, 2, Float64, 12}: The Jacobian of the interpolation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/utilities/#CRTBPNaturalMotion.jacobian-Union{Tuple{IT}, Tuple{CRTBPNaturalMotion.FastChebInterpolation{IT}, Any}} where IT","page":"Utilities","title":"CRTBPNaturalMotion.jacobian","text":"jacobian(m::FastChebInterpolation{IT}, τ1) where IT -> SVector{6, Float64}\n\nEvaluate the Jacobian of the interpolation at the given τ1 for a uni-variate interpolation.\n\nArguments\n\nm::FastChebInterpolation{IT}: The interpolation object.\nτ1: The variable.\n\nReturns\n\nSVector{6, Float64}: The Jacobian of the interpolation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/utilities/#CRTBPNaturalMotion.load_interp-Tuple{String}","page":"Utilities","title":"CRTBPNaturalMotion.load_interp","text":"load_interp(file::String) -> FastChebInterpolation{IT}\n\nLoad an interpolation object from a file.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/utilities/#CRTBPNaturalMotion.save_interp-Union{Tuple{IT}, Tuple{String, CRTBPNaturalMotion.FastChebInterpolation{IT}}} where IT","page":"Utilities","title":"CRTBPNaturalMotion.save_interp","text":"save_interp(file::String, it::FastChebInterpolation{IT}) where IT\n\nSave the interpolation object to a file.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/utilities/#CRTBPNaturalMotion.value-Union{Tuple{IT}, Tuple{CRTBPNaturalMotion.FastChebInterpolation{IT}, Any}} where IT","page":"Utilities","title":"CRTBPNaturalMotion.value","text":"value(m::FastChebInterpolation{IT}, τ1[, τ2]) where IT -> SVector{6, Float64}\n\nEvaluate the interpolation at the given τ1 and τ2 (if employing a bi-variate interpolation).\n\nArguments\n\nm::FastChebInterpolation{IT}: The interpolation object.\nτ1: The variable.\nτ2: The second variable (if employing a bi-variate interpolation).\n\nReturns\n\nSVector{6, Float64}: The interpolated state.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/type_flags/#Type-Flags","page":"Type Flags","title":"Type Flags","text":"","category":"section"},{"location":"lib/public/type_flags/","page":"Type Flags","title":"Type Flags","text":"Modules = [CRTBPNaturalMotion]\nPages = [\"type_flags.jl\"]\nPrivate = false","category":"page"},{"location":"lib/public/type_flags/#CRTBPNaturalMotion.ArcLength","page":"Type Flags","title":"CRTBPNaturalMotion.ArcLength","text":"ArcLength\n\nA concrete type to represent arc-length as the independant variable.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/type_flags/#CRTBPNaturalMotion.Time","page":"Type Flags","title":"CRTBPNaturalMotion.Time","text":"Time\n\nA concrete type to represent time as the independant variable.\n\n\n\n\n\n","category":"type"},{"location":"periodic_orbit_example/#Computing-Halo-Orbits","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"","category":"section"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"We'll first define some initial guess for a reference state of a periodic orbit of Type A. For this class of periodic orbits, we'll need to specify a position component in the hatx- and hatz-directions of the synodic (rotating) reference frame (i.e., r_x and r_z), as well as a velocity component in the haty-direction (v_y). This will correspond to the full state mathbfx = r_x 00 r_z 00 v_y 00^T, which lies in the hatx-hatz plane with velocity perpendicular to this plane. Note we'll also define the mass parameter for the Earth-Moon system, which is given by mu = m_2  (m_1 + m_2) (where here, m_1 is the mass of the Earth and m_2 is the mass of the Moon).","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"# CRTBP mass parameter\nmu = 1.21506038e-2\n\n# Define initial state guess\nrx_guess = 0.8233851820\nrz_guess = -0.0222775563\nvy_guess = 0.1341841703\nnothing # hide","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"We'll now compute the Jacobi integral (the only constant of motion for the CRTBP model) that corresponds to this initial state. Note we'll also load CRTBPNaturalMotion.jl and the StaticArrays.jl package so we can use their fast arrays here (and later).","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"using CRTBPNaturalMotion\nusing StaticArrays\n\nC_guess = jacobi_integral(SA[rx_guess, 0.0, rz_guess, 0.0, vy_guess, 0.0], mu)\nnothing # hide","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"Finally, we can now construct a TypeAPeriodicOrbit employing our initial guess, which will get corrected to a periodic orbit that satisfies an extra constraint (as a keyword argument). We'll chose a constraint that requires the Jacobi integral of the final orbit to be close to, but not quite the same, as the Jacobi integral corresponding to our initial guess. Note we'll also specify the keyword argument N_cross, which sets the number of times the periodic orbit will pass through the hatx-hatz plane in half and orbital period (i.e., N_cross = 1 means we'll pass through this plane twice if traveling around the full orbit).","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"halo = TypeAPeriodicOrbit(\n    rx_guess, rz_guess, vy_guess, mu;\n    N_cross = 1,\n    constraint = (:jacobi_integral, C_guess - 0.001),\n)","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"Finally, we have some useful functions for using this TypeAPeriodicOrbit. For now, we'll just use the get_full_orbit function to obtain a DifferentialEquations.jl solution containing the states around the full orbit so we can plot using CairoMakie.jl.","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"using CairoMakie\n\ntraj = get_full_orbit(halo)\n\nfig = Figure(); \nax  = Axis3(\n    fig[1,1]; \n    aspect = :data,\n    xlabel = L\"$r_x$, DU\",\n    ylabel = L\"$r_y$, DU\",\n    zlabel = L\"$r_z$, DU\",\n)\nlines!(ax, traj[1,:], traj[2,:], traj[3,:])\nsave(\"halo_orbit_plot.svg\", fig); nothing # hide","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"(Image: )","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"Let's now try to compute a bunch of periodic orbits using a natural continuation based approach, where we'll gradually adjust the value of the constraint while solving for new periodic orbits repeatedly (taking the previous solution as the next initial guess). Note that there are much better methods of performing continuation to compute families of periodic orbit, but this is quick example that is simple to implement.","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"# Define starting orbit\nstart_orbit = TypeAPeriodicOrbit(\n    rx_guess, rz_guess, vy_guess, mu;\n    N_cross = 1,\n    constraint = (:jacobi_integral, C_guess),\n)\n\n# Set desired rx and number of steps to take\nC_final = C_guess - 0.05\nn_steps = 100\n\n# Perform continuation in loop\nCs = range(C_guess, C_final; length = n_steps)\norbits = [start_orbit]\nfor (i, C) in enumerate(Cs)\n    new_orbit = TypeAPeriodicOrbit(\n        orbits[end];\n        constraint = (:jacobi_integral, C)\n    )\n    push!(orbits, new_orbit)\n\n    # Update our figure\n    if mod(i, 10) == 0\n        new_traj = get_full_orbit(new_orbit)\n        lines!(ax, new_traj[1,:], new_traj[2,:], new_traj[3,:]; color = :red)\n    end\nend\nsave(\"halo_orbit_cont_plot.svg\", fig); nothing # hide","category":"page"},{"location":"periodic_orbit_example/","page":"Computing Halo Orbits","title":"Computing Halo Orbits","text":"(Image: )","category":"page"},{"location":"lib/internal/temp/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internal/temp/","page":"Internals","title":"Internals","text":"Listing all non-exported types and functions here for now, but split off categories onto separate pages in the future!","category":"page"},{"location":"lib/internal/temp/","page":"Internals","title":"Internals","text":"Modules = [CRTBPNaturalMotion]\nPublic = false","category":"page"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.ParameterizationType","page":"Internals","title":"CRTBPNaturalMotion.ParameterizationType","text":"ParameterizationType\n\nA Union type for the different types of parameterizations that can be used when parameterizing a periodic orbit or its associated invairiant stable or intable manifold.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.AbstractIndependantVariable","page":"Internals","title":"CRTBPNaturalMotion.AbstractIndependantVariable","text":"AbstractIndependantVariable\n\nAn abstract type to encompas all supported independant variables.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.AbstractInterpolationWrapper","page":"Internals","title":"CRTBPNaturalMotion.AbstractInterpolationWrapper","text":"AbstractInterpolationWrapper\n\nAnd abstract type that is used to define the interface for interpolation objects.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.AbstractManifold","page":"Internals","title":"CRTBPNaturalMotion.AbstractManifold","text":"AbstractManifold\n\nAbstract type for manifolds.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.FastChebInterpolation","page":"Internals","title":"CRTBPNaturalMotion.FastChebInterpolation","text":"FastChebInterpolation(it::IT) <: AbstractInterpolationWrapper\n\nA wrapper for FastChebInterp.ChebPoly that's functional for both the FastChebInterp.jl implementations of interpolation and least-squares regression (see FastChebInterp.jl for details).\n\nFields\n\nit::IT: The FastChebInterp.ChebPoly struct.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.ParameterListType","page":"Internals","title":"CRTBPNaturalMotion.ParameterListType","text":"ParameterListType\n\nA Union type of the acceptable types for a list of parameter values.\n\n\n\n\n\n","category":"type"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_full_initial_state-Tuple{TypeAPeriodicOrbit}","page":"Internals","title":"CRTBPNaturalMotion.get_full_initial_state","text":"get_full_initial_state(orbit::AbstractPeriodicOrbit)\n\nGet the full initial reference state of the periodic orbit.\n\nArguments\n\norbit::AbstractPeriodicOrbit: The periodic orbit.\n\nReturns\n\nx0::SVector{6,Float64}: The full initial state of the periodic orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_jacobi_integral-Tuple{CRTBPNaturalMotion.AbstractPeriodicOrbit}","page":"Internals","title":"CRTBPNaturalMotion.get_jacobi_integral","text":"get_jacobi_integral(orbit::AbstractPeriodicOrbit)\n\nGet the Jacobi integral of the periodic orbit.\n\nArguments\n\norbit::AbstractPeriodicOrbit: The periodic orbit.\n\nReturns\n\nC::Float64: The Jacobi integral of the periodic orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_orbit_length-Tuple{CRTBPNaturalMotion.AbstractPeriodicOrbit, Type{Time}}","page":"Internals","title":"CRTBPNaturalMotion.get_orbit_length","text":"get_orbit_length(orbit::TypeAPeriodicOrbit, type::Type{AbstractIndependantVariable})\n\nGet the length of the periodic orbit in the desired variable.\n\nArguments\n\norbit::TypeAPeriodicOrbit: The periodic orbit.\ntype::Type{AbstractIndependantVariable}: The type of length to return.\n\nReturns\n\nlength::Float64: The length of the periodic orbit in the desired variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_stable_manifold_initial_condition-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Internals","title":"CRTBPNaturalMotion.get_stable_manifold_initial_condition","text":"get_stable_manifold_initial_condition(\n    man::InvariantManifold, left_pert::Bool, τ1::AbstractFloat, PT::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns the initial condition for a stable manifold trajectory as parameterized by τ1 ∈ [0,1].\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT::ParameterizationType: The parameterization type for the τ1 parameter.\n\nKeyword Arguments\n\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\nReturns\n\nx0m::SVector{6,Float64}: The initial condition for the stable manifold trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_state_and_monodromy_matrix-Tuple{CRTBPNaturalMotion.AbstractPeriodicOrbit, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Internals","title":"CRTBPNaturalMotion.get_state_and_monodromy_matrix","text":"get_state_and_monodromy_matrix(orbit::AbstractPeriodicOrbit, τ1::AbstractFloat, PT::ParameterizationType)\n\nGet the state and monodromy matrix of the periodic orbit at a give state parameterized by τ1 ∈ [0, 1] in terms of PT.\n\nArguments\n\norbit::AbstractPeriodicOrbit: The periodic orbit.\nτ1::AbstractFloat: The parameterization of the final state on the orbit.\nPT::ParameterizationType: The type of parameterization to use.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_state_and_stm-Union{Tuple{SMatrix{6, 7, T, 42}}, Tuple{T}} where T","page":"Internals","title":"CRTBPNaturalMotion.get_state_and_stm","text":"get_state_and_stm(z::SMatrix{6,7,T,42}) where T\n\nGet the state and state transition matrix (STM) from the full integration matrix.\n\nArguments\n\nz::SMatrix{6,7,T,42}: Matrix with first column as the state and the remaining 6 x 6 as   the STM.\n\nReturns\n\nTuple{SVector{6,T},SMatrix{6,6,T,36}: The state vector and the state transition matrix   in a return tuple.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_stm-Union{Tuple{SMatrix{6, 7, T, 42}}, Tuple{T}} where T","page":"Internals","title":"CRTBPNaturalMotion.get_stm","text":"get_stm(z::SMatrix{6,7,T,42}) where T\n\nGet the state transition matrix (STM) from the full integration matrix.\n\nArguments\n\nz::SMatrix{6,7,T,42}: Matrix with first column as the state and the remaining 6 x 6 as   the STM.\n\nReturns\n\nSMatrix{6,6,T,36}: The state transition matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.get_unstable_manifold_initial_condition-Tuple{InvariantManifold, Bool, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Internals","title":"CRTBPNaturalMotion.get_unstable_manifold_initial_condition","text":"get_unstable_manifold_initial_condition(\n    man::InvariantManifold, left_pert::Bool, τ1::AbstractFloat, PT::ParameterizationType;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nReturns the initial condition for a unstable manifold trajectory as parameterized by τ1 ∈ [0,1].\n\nArguments\n\nman::InvariantManifold: The invariant manifold.\nleft_pert::Bool: If true, the perturbation is to the left of the periodic orbit.\nτ1::AbstractFloat: The parameter for the initial condition on the periodic orbit.\nPT::ParameterizationType: The parameterization type for the τ1 parameter.\n\nKeyword Arguments\n\nsolver = Vern9(): The DifferentialEquations.jl solver to use.\nreltol = 1e-14: The relative tolerance for the solver.\nabstol = 1e-14: The absolute tolerance for the solver.\n\nReturns\n\nx0m::SVector{6,Float64}: The initial condition for the stable manifold trajectory.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.initial_state_with_stm-Union{Tuple{SVector{6, T}}, Tuple{T}} where T","page":"Internals","title":"CRTBPNaturalMotion.initial_state_with_stm","text":"initial_state_with_stm(x0::SVector{6,T}) where T\n\nCreate the initial state with the state transition matrix (STM).\n\nArguments\n\nx0::SVector{6,T}: Initial state vector.\n\nReturns\n\nSMatrix{6,7,T,42}: Matrix with first column as the state and the remaining 6 x 6 as   the STM initial condition (i.e., [x0, I]).\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.jacobi_integral_gradient-Tuple{Any, Any}","page":"Internals","title":"CRTBPNaturalMotion.jacobi_integral_gradient","text":"jacobi_integral_gradient(x, μ)\n\nComputes the gradient of the Jacobi integral for the CRTBP given the state x and mass parameter μ.\n\nArguments\n\nx::AbstractVector: State vector.\nμ::Real: Mass parameter.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.natural_crtbp_and_time_eom_with_independant_arclen-Tuple{Any, Any, Any}","page":"Internals","title":"CRTBPNaturalMotion.natural_crtbp_and_time_eom_with_independant_arclen","text":"natural_crtbp_and_time_eom_with_independant_arclen(x, p, t)\n\nCompute the equations of motion for the CRTBP model with an extra state  for the time with only natural motion. Here the independant variable has been  transformed from time to arc-length.\n\nArguments\n\nx::SVector{7}: State vector, i.e., [position^T; velocity^T].\np::Tuple{Float64,}: Tuple of parameters, (mu,)\nt::Float64: Time.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.natural_crtbp_eom-Tuple{Any, Any, Any}","page":"Internals","title":"CRTBPNaturalMotion.natural_crtbp_eom","text":"natural_crtbp_eom(x, p, t)\n\nCompute the equations of motion for the CRTBP model with only natural motion.\n\nArguments\n\nx::SVector{6}: State vector, i.e., [position^T; velocity^T].\np::Tuple{Float64,Float64,Float64}: Tuple of parameters, (mu,)\nt::Float64: Time.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.natural_crtbp_eom_with_arclen-Tuple{Any, Any, Any}","page":"Internals","title":"CRTBPNaturalMotion.natural_crtbp_eom_with_arclen","text":"natural_crtbp_eom_with_arclen(x, p, t)\n\nCompute the equations of motion for the CRTBP model with only natural motion,  employing the arclength along the trajectory as an additional state.\n\nArguments\n\nx::SVector{7}: State vector, i.e., [position^T; velocity^T; arc-len].\np::Tuple{Float64,}: Tuple of parameters, (mu,)\nt::Float64: Time.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.natural_crtbp_eom_with_independant_arclen-Tuple{Any, Any, Any}","page":"Internals","title":"CRTBPNaturalMotion.natural_crtbp_eom_with_independant_arclen","text":"natural_crtbp_eom_with_independant_arclen(x, p, t)\n\nCompute the equations of motion for the CRTBP model with only natural motion where the independant variable has been transformed from time to arc-length.\n\nArguments\n\nx::SVector{7}: State vector, i.e., [position^T; velocity^T].\np::Tuple{Float64,}: Tuple of parameters, (mu,)\nt::Float64: Time.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.natural_crtbp_eom_with_stm-Tuple{Any, Any, Any}","page":"Internals","title":"CRTBPNaturalMotion.natural_crtbp_eom_with_stm","text":"natural_crtbp_eom_with_stm(x, p, t)\n\nCompute the equations of motion for the CRTBP model with the state transition matrix.\n\nArguments\n\nx::SMatrix{6,7,Float64}: Matrix with first column ast the state and the remaining 6 x 6 as the STM.\np::Tuple{Float64,}: Tuple of parameters, (mu,)\nt::Float64: Time.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.propagate_from_initial_conditions-Tuple{CRTBPNaturalMotion.AbstractPeriodicOrbit, AbstractFloat, Union{Type{ArcLength}, Type{Time}}}","page":"Internals","title":"CRTBPNaturalMotion.propagate_from_initial_conditions","text":"propagate_from_initial_conditions(\n    orbit::AbstractPeriodicOrbit, τ1::AbstractFloat, PT::ParameterizationType,\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n)\n\nPropagate the periodic orbit from the initial conditions to another state on the orbit, as parameterized by τ1 ∈ [0, 1] in terms of PT::ParameterizationType.\n\nArguments\n\norbit::AbstractPeriodicOrbit: The periodic orbit.\nτ1::AbstractFloat: The parameterization of the final state on the orbit.\nPT::ParameterizationType: The type of parameterization to use.\n\nKeyword Arguments\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The ODE solver to use for the integration.\nreltol::Real: The relative tolerance for the ODE solver.\nabstol::Real: The absolute tolerance for the ODE solver.\n\nReturns\n\nx1::SVector{6,Float64}: The final state on the periodic orbit.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.propagate_return_final_state_and_stm-Union{Tuple{TT}, Tuple{TX}, Tuple{SVector{6, TX}, Tuple{TT, TT}, Any}} where {TX, TT}","page":"Internals","title":"CRTBPNaturalMotion.propagate_return_final_state_and_stm","text":"propagate_return_final_state_and_stm(\n    x0::SVector{6,TX}, tspan::Tuple{TT,TT}, mu;\n    solver = Vern9(),\n    reltol = 1e-14,\n    abstol = 1e-14,\n) where {TX,TT}\n\nPropagate the state x0 over the time span tspan and return the final state and the state transition matrix (STM).\n\narguments\n\nx0::SVector{6,TX}: The initial state with x0 = [r0; v0].\ntspan::Tuple{TT,TT}: The span of the independant variable forwhich to solve the ode.\nmu::Real: The mass parameter of the three-body system (mu = m2 / (m1 + m2)).\n\nkeywords\n\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nreturns\n\nSMatrix{6,6,TX,36}: The stm for the full trajectory\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.typeA_shooting_function-Union{Tuple{T}, Tuple{SVector{4, T}, Any}} where T","page":"Internals","title":"CRTBPNaturalMotion.typeA_shooting_function","text":"typeA_shooting_function(u, p; constraint = (:x_start_coordinate, 0.0))\n\nShooting function for computing Type A periodic orbits in the CRTBP using the methodology described by Restrepo and Russell in A database of planar axisymmetric periodic orbits for the solar system doi: 10.1007/s10569-018-9844-6.\n\nArguments\n\nu::SVector{4,T}: Vector of decision variables, [rx, rz, vy, P / 2], where P is half of   the orbital period.\np::Tuple{Float64,}: Tuple of parameters, (mu,), where mu is the mass parameter.\n\nKeyword Arguments\n\nconstraint::Tuple{Symbol,Real}: Tuple of the constraint type and value corresponding   to the final constraint considered to provide a fully defined system of nonlinear   eqautions. The constraint type can be either :x_start_coordinate or :jacobi_integral.   The constraint value is the value that the constraint should be equal to for the desired   periodic orbit. Note that new constraints can be added with relative ease through   modification of this function and its corresponding jacobian function   typeA_shooting_jacobian.\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nReturns\n\nSVector{4,T}: Vector of residuals for the nonlinear system of equations.\n\n\n\n\n\n","category":"method"},{"location":"lib/internal/temp/#CRTBPNaturalMotion.typeA_shooting_jacobian-Union{Tuple{T}, Tuple{SVector{4, T}, Any}} where T","page":"Internals","title":"CRTBPNaturalMotion.typeA_shooting_jacobian","text":"typeA_shooting_jacobian(u, p; constraint = (:x_start_coordinate, 0.0))\n\nThe Jacobian of the shooting function for computing Type A periodic orbits in the CRTBP using the methodology described by Restrepo and Russell in A database of planar axisymmetric periodic orbits for the solar system doi: 10.1007/s10569-018-9844-6.\n\nArguments\n\nu::SVector{4,T}: Vector of decision variables, [rx, rz, vy, P / 2], where P is half of   the orbital period.\np::Tuple{Float64,}: Tuple of parameters, (mu,), where mu is the mass parameter.\n\nKeyword Arguments\n\nconstraint::Tuple{Symbol,Real}: Tuple of the constraint type and value corresponding   to the final constraint considered to provide a fully defined system of nonlinear   eqautions. The constraint type can be either :x_start_coordinate or :jacobi_integral.\nsolver::OrdinaryDiffEq.AbstractODESolver: The solver to use for the integration.\nreltol: The relative tolerance for the solver.\nabstol: The absolute tolerance for the solver.\n\nReturns\n\nSMatrix{4,4,T,16}: Jacobian of the nonlinear system of equations.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CRTBPNaturalMotion","category":"page"},{"location":"#CRTBPNaturalMotion","page":"Home","title":"CRTBPNaturalMotion","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CRTBPNaturalMotion is a package for computing periodic orbits and they're associated stable/unstable invariant manifolds, as well as performing various analyses in the CRTBP model assuming only natural motion (i.e., no control). The package also provides an interface for querying CRTBP periodic orbits in JPL's Poincare Catalog of Period Orbits. ","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
